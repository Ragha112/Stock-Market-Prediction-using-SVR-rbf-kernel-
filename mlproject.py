# -*- coding: utf-8 -*-
"""MLProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MohCQjlZ11fD3yCn6Jiu0zKxliFNeI_V
"""

# 🧠 Stock Market Prediction using Support Vector Regression (SVR)
# ---------------------------------------------------------------
# Predicts next-day stock prices for Apple (AAPL) and Microsoft (MSFT)
# Uses 5-year data from yFinance, EMA-14, GridSearchCV tuning, and evaluates with MSE & R²
# Finally recommends the better-performing stock based on predicted growth.

# Step 1: Install dependencies
!pip install yfinance scikit-learn matplotlib pandas numpy --quiet

# Step 2: Import required libraries
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score, accuracy_score, precision_score, recall_score, f1_score

# Step 3: Fetch stock data and compute EMA-14
def fetch_stock_data(ticker):
    df = yf.download(ticker, period="5y")
    df['EMA14'] = df['Close'].ewm(span=14, adjust=False).mean()
    df['Prediction'] = df['Close'].shift(-1)
    df.dropna(inplace=True)
    return df

stock1, stock2 = 'AAPL', 'MSFT'
data1 = fetch_stock_data(stock1)
data2 = fetch_stock_data(stock2)

print(f"\n{stock1} Dataset Sample:")
display(data1.head())
print(f"\n{stock2} Dataset Sample:")
display(data2.head())

# Step 4: Find best SVR parameters using GridSearchCV
def find_best_params(X_train_scaled, y_train):
    param_grid = {
        'C': [0.1, 1, 10, 100],
        'gamma': [0.0001, 0.001, 0.01, 0.1]
    }
    svr = SVR(kernel='rbf')
    grid = GridSearchCV(svr, param_grid, scoring='neg_mean_squared_error', cv=5)
    grid.fit(X_train_scaled, y_train)
    print("🔍 Best Parameters:", grid.best_params_)
    return grid.best_estimator_

# Step 5: Train, predict, and evaluate SVR
def predict_stock_price(df):
    X = df[['Open', 'High', 'Low', 'Close', 'Volume', 'EMA14']]
    y = df['Prediction']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, shuffle=False)

    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    model = find_best_params(X_train_scaled, y_train)

    latest_features = scaler.transform(X.tail(1))
    predicted_price = model.predict(latest_features)[0]

    predictions = model.predict(X_test_scaled)
    mse = mean_squared_error(y_test, predictions)
    r2 = r2_score(y_test, predictions)

    return predicted_price, mse, r2, predictions, y_test, df

# Step 6: Run predictions for both stocks
pred_price1, mse1, r21, pred1, y_test1, full_df1 = predict_stock_price(data1)
pred_price2, mse2, r22, pred2, y_test2, full_df2 = predict_stock_price(data2)

print(f"\n{stock1} Predicted Next-Day Price: ${pred_price1:.2f}")
print(f"{stock1} → MSE: {mse1:.4f}, R²: {r21:.4f}")
print(f"\n{stock2} Predicted Next-Day Price: ${pred_price2:.2f}")
print(f"{stock2} → MSE: {mse2:.4f}, R²: {r22:.4f}")

# Step 7: Visualization (Actual vs Predicted vs EMA)
plt.figure(figsize=(15,10))

# AAPL
plt.subplot(2,1,1)
plt.plot(y_test1.values[-60:], label='Actual Price', color='blue')
plt.plot(pred1[-60:], label='Predicted Price', color='orange')
plt.plot(full_df1['EMA14'].iloc[-60:].values, label='EMA14', color='green', linestyle='--')
plt.title(f'{stock1} Actual vs Predicted vs EMA14 (Last 60 Days)')
plt.xlabel('Days')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid()

# MSFT
plt.subplot(2,1,2)
plt.plot(y_test2.values[-60:], label='Actual Price', color='blue')
plt.plot(pred2[-60:], label='Predicted Price', color='orange')
plt.plot(full_df2['EMA14'].iloc[-60:].values, label='EMA14', color='green', linestyle='--')
plt.title(f'{stock2} Actual vs Predicted vs EMA14 (Last 60 Days)')
plt.xlabel('Days')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid()

plt.tight_layout()
plt.show()

# Step 8: Growth calculation and recommendation
latest_close1 = float(data1['Close'].iloc[-1])
latest_close2 = float(data2['Close'].iloc[-1])

growth1 = ((pred_price1 - latest_close1) / latest_close1) * 100
growth2 = ((pred_price2 - latest_close2) / latest_close2) * 100

print(f"\n{stock1} Expected Growth: {growth1:.2f}%")
print(f"{stock2} Expected Growth: {growth2:.2f}%")

if growth1 > growth2 and growth1 > 0:
    print(f"\nRecommendation: Invest in {stock1}")
elif growth2 > growth1 and growth2 > 0:
    print(f"\nRecommendation: Invest in {stock2}")
elif growth1 < 0 and growth2 < 0:
    print("\nBoth stocks expected to decline. Exercise caution.")
else:
    print("\nNeutral outlook. Consider further analysis.")

# Step 9: Directional accuracy evaluation
def classify_direction(actual, predicted):
    actual_dir = np.where(np.diff(actual) > 0, 1, 0)
    predicted_dir = np.where(np.diff(predicted) > 0, 1, 0)
    return actual_dir, predicted_dir

def evaluate_direction(stock, y_test, pred):
    actual_dir, pred_dir = classify_direction(y_test.values, pred)
    accuracy = accuracy_score(actual_dir, pred_dir)
    precision = precision_score(actual_dir, pred_dir)
    recall = recall_score(actual_dir, pred_dir)
    f1 = f1_score(actual_dir, pred_dir)
    std_dev = np.std(y_test.values - pred)
    print(f"\n📊 Directional Metrics for {stock}:")
    print(f"Accuracy: {accuracy:.2f}, Precision: {precision:.2f}, Recall: {recall:.2f}, F1: {f1:.2f}")
    print(f"Std Dev of Prediction Error: {std_dev:.4f}")

evaluate_direction(stock1, y_test1, pred1)
evaluate_direction(stock2, y_test2, pred2)

# Step 10: Project Summary
print("""
📘 Stock Market Prediction using Support Vector Regression (SVR)
---------------------------------------------------------------
• Predicts next-day prices for Apple (AAPL) & Microsoft (MSFT)
• Uses EMA14 and GridSearchCV for tuning
• Evaluates with MSE, R², and visualizes results
• Recommends the better-performing stock based on growth
""")
